port

 { agen=
tsRouter } 

from

'./routes/agents'

=

;

import

 { chat=
Router } 

from

=

'./routes/chat'

;

import

 { atta=
chSockets } 

from

'./sockets'

;

const

 app =3D=

express

();
app.

use

(

helmet

()); app.

use

(

cors

({ 

origin

: 

/symbi\.world$/

 }));=20
app.

use

(express.

json

({ 

limit

: 

'1mb'

 }));
app.

use

(

rateLimit

({ 

windowMs

: 

60_000

, 

max

: 

=

120

 }));

app.

use

(

'/api/auth'

=
, authRouter);
app.

use

(

'/api/trust'

, trustRouter);
app.

use

(

'/api/agents'

, agentsRouter);
app.

use

(

'/api/chat'

=
, chatRouter);

const

 server =
=3D app.

listen

(process.

env

.

PORT

 || 

4000

, 

() =3D>

console

.

log

(

'API up'

));

attachSockets

(server); 

// Socket.io + =
Redis adapter

Trust Bond model (excerpt)

ts

Copy code

// apps/api/src/models/Trus=
tBond.ts

import

 { 

Schema

, mode=
l } 

from

'mongoose'

;

const

=

TrustBondSchema

=
 =3D 

new

Schema

({

human_id

: { 

type

: 

Schema

.

=

Types

.

ObjectId

, 

ref

: 

'User'

, 

index

: 

true

, 

required
=

: 

true

=

 },

agent_id

: { 

type

: 

Schema

.

=

Types

.

ObjectId

, 

ref

: 

'Agent'

, 

index

: 

true=

, 

required

: 

true

 },

state

: { 

type

: 

String

, 

enum

: [

'provisional'

,

'active'

,

'monitored'

,

'suspended'

,

'revoked'

], 

default

: 

'=
provisional'

 },

score

: { 

current

: { 

type

: 

Number

, 

default

: 

0

 }, 

updated_at

: { 

type

: 

D=
ate

, 

default

: 

Date

.

now

=

 } },

policy

: {

required_kyc_level

=

: 

Number

=

, 

min_score

: 

Number

, 

scopes_required

: [

String

],
  },

consent_envelope_id

: { 

type

: 

Schema

.

Types

.

ObjectId

, 

ref

: 

'ConsentEnvelope'

, 

required

: 

true

 },

history

: [{ 

at

: 

Date

, 

delta

: 

Number

, 

reason

: 

String

, 

actor

: 

String

 }],

violations

: [{=

at

: 

Date

, 

=

code

: 

String

, 

severity

: 

String

, 

resolved

: 

Boolean

 }],

created_at

: { =

type

: 

Date

, 

default

: 

Date

.

now

 }
}, { 

timestamps

:=

false

 });

TrustBondSchema

.

index

({ 

human_id

: 

1

, 

agent_id

: 

1

 }, { 

unique

: 

true

 });

export

default

model

(

'TrustBond'

, 

TrustBondSchema

);

Trust Gate middleware (excerpt)

ts

Copy code

// apps/api/src/middleware/=
trustGate.ts

export

async

=

function

trustGate

(

req, res, next

) {

const

 { hum=
anId, agentId, scope } =3D req.

b=
ody

 ?? req.

q=
uery

;

const

 bond =
=3D 

await

TrustBond

.

findOne

({ 

human_id

: hu=
manId, 

agent_id

:=
 agentId }).

populate

(

'consent_envelope_=
id'

);

if

 (!bond) =

return

 res.

status

(=

403

).

json

({ 
=

error

: 

'No bond'

 });

if

 ([

'suspended'

,

'revoked'

].

includes

(bond.

state

)) 

return

 res.

status

(

403

).

json

({ 

=

error

: 

'Bond not active'

 });

if

 (bond.

score

.

current

 < (bond.

policy

.

min_score

 ?? 

60

)) 

return

 res.

status

(

403

).

json

({ 

error

: 

'Trust too low'

 });

const

 allow=
ed =3D bond.

consent_envelope_id

.

scopes

.

includes

(scope);

if

 (!allowe=
d) 

return

 res=
.

status

(

403

).

json

({ 

error

: 

=

'Out-of-scope'

, 

ask_consent

: 

true

 });

return

next

();
}

9) UI: trust=E2=80=91aware chat=
 & bond meter

Meter
: color=E2=80=91agnostic bar with score + sta=
te chips; hover =E2=86=92 policy & last deltas.

Boundary hints
: inline banners when scope mismatch=
es; =E2=80=9CRequest expanded consent=E2=80=9D flow.

Transcript tags
: each message stamped with bond sn=
apshot (score,state).

Admin views
: violations timeline; consent diff vie=
wer; score contributors waterfall.

10) Testing & SLOs

Unit
: 80%+ on scoring, gate, auth flows.

Integration
: trust lifecycle, consent update, viol=
ation remediation.

E2E
: create bond =E2=86=92 chat =E2=86=92 violatio=
n =E2=86=92 suspension =E2=86=92 remediation =E2=86=92 restore.
