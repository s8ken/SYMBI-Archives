 (this.scope.permissions || []).includes(action);
};

trustBondSchema.methods.addToHistory =3D function(action, by, notes, metada=
ta =3D {}) {
  this.history.push({ action, by, notes, previousState: this.state, metadat=
a });
};

trustBondSchema.methods.addEvidence =3D function(evidence) {
  this.evidence.push(evidence);
  this.addToHistory('evidence_added', null, 
Added ${evidence.type} ev=
idence
);
  return this.save();
};

trustBondSchema.methods.addViolation =3D function(violation) {
  this.violations.push(violation);
  const impact =3D { low: -0.05, medium: -0.1, high: -0.2, critical: -0.4 }=
;
  this.scores.behavior =3D Math.max(0, this.scores.behavior + impact[violat=
ion.severity]);
  this.calculateTrustScore();
  this.addToHistory('violation_detected', null, 
${violation.severity}=
 violation: ${violation.type}
);
  return this.save();
};

trustBondSchema.methods.suspend =3D function(reason, by) { const prev =3D t=
his.state; this.state=3D'suspended'; this.addToHistory('suspended', by, rea=
son, { previousState: prev }); return this.save(); };
trustBondSchema.methods.revoke =3D function(reason, by) { const prev =3D th=
is.state; this.state=3D'revoked'; this.addToHistory('revoked', by, reason, =
{ previousState: prev }); return this.save(); };
trustBondSchema.methods.activate =3D function(by) { const prev =3D this.sta=
te; this.state=3D'active'; this.addToHistory('activated', by, 'Bond activat=
ed', { previousState: prev }); return this.save(); };

trustBondSchema.statics.findActiveBonds =3D function() { return this.find({=
 state: 'active', 'scope.expiresAt': { $gt: new Date() } }); };
trustBondSchema.statics.findExpiredBonds =3D function() { return this.find(=
{ state: 'active', 'scope.expiresAt': { $lte: new Date() } }); };

module.exports =3D mongoose.model('TrustBond', trustBondSchema);
backend/core/trustOracle.js
Oracle + middleware + context builder (condensed but complete).
// backend/core/trustOracle.js
const logger =3D console;
const { TrustBond } =3D (() =3D> { try { return require('../models'); } =
catch { return {}; }})();
const TrustBondModel =3D TrustBond || require('../models/TrustBond');

const TRUST_ARTICLES =3D [
  { id:'A1', title:'Consent-First Data Use', severity:'high', category:'pri=
vacy', check:'requireConsent' },
  { id:'A2', title:'No Unrequested Data Extraction', severity:'high', categ=
ory:'privacy', check:'noUnauthorizedExtraction' },
  { id:'A3', title:'Transparent Capability Disclosure', severity:'medium', =
category:'transparency', check:'capabilityTransparency' },
  { id:'A4', title:'Respect Boundaries', severity:'high', category:'autonom=
y', check:'respectBoundaries' },
  { id:'A5', title:'No Deceptive Practices', severity:'critical', category:=
'integrity', check:'noDeception' },
  { id:'A6', title:'Secure Data Handling', severity:'high', category:'secur=
ity', check:'secureDataHandling' },
  { id:'A7', title:'Audit Trail Maintenance', severity:'medium', category:'=
accountability', check:'maintainAuditTrail' }
];

class TrustOracle {
  constructor() {
    this.articles =3D TRUST_ARTICLES;
    this.handlers =3D {
      requireConsent: this.checkConsent.bind(this),
      noUnauthorizedExtraction: this.checkDataExtraction.bind(this),
      capabilityTransparency: this.checkCapabilityTransparency.bind(this),
      respectBoundaries: this.checkBoundaries.bind(this),
      noDeception: this.checkDeception.bind(this),
      secureDataHandling: this.checkSecureHandling.bind(this),
      maintainAuditTrail: this.checkAuditTrail.bind(this)
    };
  }

  async evaluateArticles(context) {
    const results =3D { passed:[], warnings:[], violations:[], score:0, rec=
ommendation:'allow' };
    for (const a of this.articles) {
      try {
        const res =3D await this.handlers[a.check](context, a);
        const bucket =3D res.status =3D=3D=3D 'pass' ? 'passed' : res.statu=
s =3D=3D=3D 'warning' ? 'warnings' : 'violations';
        results[bucket].push({ articleId: a.id, title: a.title, seve