stContext

(req);

const

 eva=
luation =3D 

await

 oracle.evaluateArticles(context);

// metrics

try

 { 

recordTrustEvaluation
=

(evaluation); } 

catc=
h

 {}

if

 (evalu=
ation.

recommendation

 =3D=3D=3D 

'block'

) {

return

 =
res.

status

(

403

).

json

({ 

success

:

false

, 

error

:

'Policy violation'

, 

details

:evaluation.

violations

 });
    }

if

 (evalu=
ation.

recommendation

 =3D=3D=3D 

'restrict'

) req.

trustRestri=
ctions

 =3D evaluation.

violations

;

if

 (evalu=
ation.

recommendation

 =3D=3D=3D 

'warn'

) req.

trustWarnings

 =3D evaluation.

warnings

;
    req.

trustContext

 =3D context; req.

trustE=
valuation

 =3D evaluation;

return

next

();
  }

catch

(e){

return

 re=
s.

status

(

500

).

json

({ 

success

:

false

, 

error

:

'Trust evaluation failed'

, 

message

:e.

message

 });
  }
};

async

=

function

buildTrustContext

(

req

){

const

 actio=
nVerb =3D (req.

method

||

'get'

).

toLowerCase

();

const

 route=
Tail =3D (req.

route

 && req.

route

.

path

) ? 

String

(req.

route

.

path

) : req.

path

 || 

''

;

const

 actio=
n =3D 

`
=
${actionVerb}

.

${routeTail.split(
'/'

).filter(

Boolean

).pop()||

'unknown'

}`;

const

 ctx =
=3D {

userId

: req.=

user

?.

_id

 || req.
=

user

?.

=

id

,

agentId

: req=
.

agent

?.

_id

,
    action,

scopes

: req.=

body

?.

scopes

 || req.

query

?.

scopes

,

data

: req.

body

,

encrypted

: r=
eq.

secure

,

reqProto

: re=
q.

protocol

,

headers

: req=
.

headers

,

auditEnabled

=
: 

true

,

logEntry

: {

requestId

:=
 req.

get

?.(

'x-request-id'

)=
 || crypto.

randomUUID

(),

timestamp

:=

new

Date

(),

method

: re=
q.

method

,

path

: req.=

path

,

ip

: req.

ip

,

userAgent

:=
 req.

get

?.(

'User-Agent'

)
    }
  };

const

 bondI=
d =3D req.

body

?.

bondId

 |=
| req.

params

=
?.

bondId

;

if

 (bondId)=
{

try

{

const

 b=
ond =3D 

await

=

TrustBond

.

findById

=

(bondId);

if

 (bon=
d){ ctx.

bond

=
 =3D bond; ctx.

bondId

 =3D bondId; }
    }

catch

(e)=
{ logger.

error

(

'Bond lookup failed'

,{ bondId, 

err

:e.

message

 }); }
  }

return

 ctx;
}

module

.

exports

=
 =3D { 

TRUST_ARTICLES

, 

TrustOr=
acle

, createTrustMiddleware, buildTrustContext };

New =E2=80=94 
backend/instrumentation/trust-metrics.js

js

Copy code

const

 c=
lient =3D 

require

(

'prom-client'

);

const

 trustEv=
alCounter =3D 

new

 client.

Counter

({ 

name

: 

'trust_evaluations_total'

, 

help

: 

'Oracle evaluations'
=

, 

labelNames

: [

'recommendation'

] });

const

 trustVi=
olationCounter =3D 

new

 client.

Counter

({ 

name

: 

'trust_policy_violations_=
total'

, 

help

: 

'Policy violatio=
ns'

, 

labelNames

: [

'article'

,

'severity'

] });

function

recordTrustEvaluation

(

e

=
) {

try

 {
    trustEvalCounter.

inc

({ 

recommendation=

: e.

recommen=
dation

 || 

'unk=
nown'

 }, 

1

);
    (e.

violations

||[]).

forEach
=

(

v

 =3D> trustViolationCounter.

inc

({ 

article

: v.

articleId

, 

severity

: v.

severity

||

'unknown'

 }, 

1

));
  } 

catch

 {}
}

module

.

exports

=
 =3D { recordTrustEvaluation, 

regist=
er

: client.

r=
egister

 };

2) Routes, app wiring, and metr=
ics endpoint

backend/routes/trust-bonds.routes.js

(as you drafted=E2=80=94looks go=
od)

backend/controllers/trustBonds.controller.js

(as you drafted=E2=80=94good; yo=
u already compute 
expiresAt
)

backend/app.js
 (or your Express entry)

diff

Copy code

+const bondRoutes =3D=
 require('./routes/trust-bonds.routes');

+const { register } =3D require(=
'./instrumentation/trust-metrics');

 // ...

-app.use('/api/trust/bonds', bon=
dRoutes);

+app.use('/api/trust/bonds', bon=
dRoutes);

+app.get('/metrics', async (_req=
, res) =3D> {

+  res.set('Content-Type', regis=
ter.contentType);

+  res.end(await register.metric=
s());

+});

Wire the Oracle on =E2=8