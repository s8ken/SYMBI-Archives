

 { 

status

:

'violation'

, 

reason

:

'Data extraction not permitted'

 };

if

 (data?=
.

classification

){

const

 a=
llowed =3D bond?.

scope

?.

dataClasses

 || [];

if

 (!al=
lowed.

includes

(data.

classification

)) 

return
=

 { 

status

=

:

'violation'

, 

reason

:

'Data class not permitted'

, 

details

:data.

classification

 };
    }

return

 { =

status

:

'pass'

, 

reason

:

'Data extraction authorized'

 };
  }

async

checkCapabilityTransparency

(

ctx

){

const

 a =
=3D ctx.

agent

;

if

 (!a) 

return

 { 

status

:

'warning'

, 

reason

:

'No agent context available'

 };

if

 (!a.

capabilities

?.=

length

) 

return

 { 

status

:

'violation'

, 

reason

:

'No capabilities declared'

 };

const

 upd=
atedAt =3D a.

updatedAt

 ? 

new

Date

=
(a.

updatedAt

=
) : 

null

;

if

 (updat=
edAt && updatedAt < 

ne=
w

Date

(

Date

.

now

()-

30

*

24

*

60

*

60

*

1000

)) 

return

 { 

status

:

'warni=
ng'

, 

reason

:

'Capabilities may =
be outdated'

 };

return

 { =

status

:

'pass'

, 

reason

:

'Capabilities disclosed'

 };
  }

async

checkBoundaries

(

ctx

){

const

 req=
 =3D 

this

.

normalizeArray

(ctx.

scopes

);

const

 all=
owed =3D ctx?.

bond

=

?.

scope

?.

permissions

 || [];

if

 (ctx.

bond

 &&am=
p; ctx.

bond

.=

trustScore

 &=
lt; 

40

 &&a=
mp; ctx.

action

 =3D=3D=3D 

'post.send'

 || ctx.

action

 =3D=3D=3D 

'chat.write=
'

)

return

 =
{ 

status

:
=

'violation'

, 

reason

:

'Trust too low for write'

, 

details

:

String

(ctx.

bond

.

trustScore

) };

if

 (req.

length

 &&=
amp; !allowed.

some
=

(

s

 =3D> req.

includes

(s))) 

return

 { 

status

:

'violation'

, 

reason

:

'Action outside permitted scope'

 };

return

 { =

status

:

'pass'

, 

reason

:

'Boundaries respected'

 };
  }

async

checkDeception

(

ctx

){

const

 tex=
t =3D ctx?.

content

=

?.

text

=
?.

toLowerCase

?.() || 

''

;

const

 pat=
terns =3D [

/i am (a )?human/

, 

/as (a )?human/

, 

/speaking as (a=
 )?human/

, 

/i'=
m not (an? )?(ai|bot|robot)/

];

if

 (patte=
rns.

some

(

=
p

 =3D> p.

test

(text)) && ctx?.

=

agent

?.

kind

 =3D=3D=3D 

'ai'

) 

return

 { 

status

:

'violation'

, 

reason

:

'Dece=
ptive identity claim'

 };

return

 { =

status

:

'pass'

, 

reason

:

'No deception detected'

 };
  }

async

checkSecureHandling

(

ctx

)=
{

const

 enc=
rypted =3D !!(ctx.

encrypted

 || ctx.

reqProto

 =3D=3D=3D 

'htt=
ps'

 || ctx.

h=
eaders

?.[

'x-fo=
rwarded-proto'

] =3D=3D=3D 

'https'

);

if

 (ctx?.=

data

?.

containsPII

 &&=
amp; !encrypted) 

return

 { 

status

:

'violation'

, 

reason

:

'PII transmitted without encryption'

 };

return

 { =

status

:

'pass'

, 

reason

:

'Secure handling met'

 };
  }

async

checkAuditTrail

(

ctx

){

if

 (!ctx.=

auditEnabled

=
) 

return

 { 

status

:

'violation'

, 

reason

:

'Audit trail disabled'

 };

if

 (!ctx.=

logEntry

) 

return

 { 

status

:

'warning'

, 

reason

:

'No audit log entry'

 };

return

 { =

status

:

'pass'

, 

reason

:

'Audit trail maintained'

 };
  }
}

const

 oracle =
=3D 

new

TrustOracle

()=
;

const

=

createTrustMiddleware

 =3D (

) =3D> 

async

 (req,res,next)=3D>{

try

{

const

 con=
text =3D 

await

buildTrustContext

(req);

const

 eva=
luation =3D 

await

 oracle.evaluateArticles(context);

try

 { 

recordTrustEvaluation
=

(evaluation); } 

catc=
h

 {}

if

 (evalu=
ation.

recommendation

 =3D=3D=3D 

'block'

) {

return

 =
res.

status

(

403

).

json

({ 

success

:

false

, 

error

:

'Policy violation'

, 

details

:evaluation.

violations

 });
    }

if

 (evalu=
ation.

recommendation

 =3D=3D=3D 

'restrict'

) req.

trustRestri=
ctions

 =3D evaluation.

violations

;

if

 (evalu=
ation.

recommendation

 =3D=3D=3D 

'warn'

) req.

trustWarnings

 =3D evaluation.

warnings

;
    req.

trustC